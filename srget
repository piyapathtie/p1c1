#!/usr/bin/env python

from urlparse import urlparse
import socket as skt
import os
import sys
import asyncore 
import threading

print "start"
class srget(object):
    def __init__(self, url):
        self.kwamyao = len(sys.argv)
        self.nthread = 5
        self.fileName = sys.argv[2]
        if self.kwamyao == 6:
            self.nthread = int(sys.argv[4])
        self.lsStart = []
        self.lsFinish = []
        self.number = 0
        self.tail = "tail.txt"
        self.host, self.path, self.severPort = self.parse_url(url)
        self.clientSocket = skt.socket(skt.AF_INET, skt.SOCK_STREAM)
        self.clientSocket.connect((self.host, self.severPort))
        self.receive = 0
        self.header = ""
        self.cl = 0
        self.fileSize = ""
        self.etag = ""
        if self.kwamyao > 4: 
            self.request_str = self.make_request("GET", self.path, {"HOST": self.host, "Connection": "close"})
            self.clientSocket.send(self.request_str)
            print "send request"
            self.threadDownload()

        elif os.path.isfile(self.fileName) == False and self.kwamyao != 6:
            self.request_str = self.make_request("GET", self.path, {"HOST": self.host, "Connection": "close"})
            self.clientSocket.send(self.request_str)
            self.download()
        else:
            with open (self.tail,'r') as t:
                for each in t:
                    self.fileSize = each 
            request = "GET "+self.path+" HTTP/1.1\r\n"+ "Host: "+self.host+"\r\n"+"Connection: close\r\n"+"Range: bytes={b}-\r\n\r\n".format(b=self.fileSize)
            self.clientSocket.send(request)
            self.makeResume()
       
    def threadDownload(self):
        print "thred download"
        while True:
            self.datareceive = self.clientSocket.recv(1)
            self.header += self.datareceive 
            if "\r\n\r\n" in self.header:
                self.headerFinal, self.remain = self.header.split("\r\n\r\n")
                self.receive += len(self.remain)
                # self.f.write(self.remain)
                break
     
        contentLen = self.headerFinal.split()  
        i = 0
        for each in contentLen:
            if each == "Content-Length:":
                self.cl = contentLen[i+1]
                break
            i += 1
                
        self.cl = int(self.cl)
        count = self.cl/self.nthread
        for each in range(self.nthread):
            self.lsStart.append(count*each)
            self.lsFinish.append(count*(each+1) -1) 
        self.lsFinish.pop()
        self.lsFinish.append(self.cl)
        # print self.lsStart
        # print self.lsFinish
        zipped = zip(self.lsStart, self.lsFinish)
        print zipped
        self.clientSocket.close()
        print "socket closed"

        ls = []
        for x,y,z in zip(range(self.nthread), self.lsStart, self.lsFinish) :
            self.clientSocket = skt.socket(skt.AF_INET, skt.SOCK_STREAM)
            self.clientSocket.connect((self.host, self.severPort))
            t = threading.Thread(target=self.td(), args=(self.number))
            ls.append(t)
            t.start()
            self.number += 1

        print self.els
        for each in self.els:
            print each
        for each in ls:
            each.join()
        # self.clean_n_mix(self.fileName)

    def makeResume(self):
        try :
            print "resuming..."
            with open (self.fileName, 'a+') as self.f:
                while True:
                    datareceive = self.clientSocket.recv(1)
                    self.header += datareceive 
                    if "\r\n\r\n" in self.header:
                        headerFinal, remain = self.header.split("\r\n\r\n")
                        self.receive += len(remain)
                        print self.receive
                        self.f.write(remain)
                        break

                # print headerFinal
                contentLen = headerFinal.split()  
                i = 0
                for each in contentLen:
                    if each == "Content-Length:":
                        self.cl = contentLen[i+1]
                        break
                    i += 1

                while self.receive < self.cl :
                    datareceive = self.clientSocket.recv(2048)
                    self.receive += len(datareceive)
                    self.f.write(datareceive)
                    # print self.receive, self.cl
                    if not datareceive:
                        break

            os.remove(self.tail)
        except KeyboardInterrupt:
            t = open (self.tail, 'w')
            t.write(str(self.receive+int(self.fileSize)))
            t.close()

    def download(self): 
        try :
            print "download"     
            with open (self.fileName, 'wb') as self.f:
                while True:
                    self.datareceive = self.clientSocket.recv(1)
                    self.header += self.datareceive 
                    if "\r\n\r\n" in self.header:
                        self.headerFinal, self.remain = self.header.split("\r\n\r\n")
                        self.receive += len(self.remain)
                        self.f.write(self.remain)
                        break
     
                contentLen = self.headerFinal.split()  
                i = 0
                for each in contentLen:
                    # print each
                    if each == "Content-Length:":
                        self.cl = contentLen[i+1]
                        break
                    i += 1
 
                while self.receive < self.cl:
                    datareceive = self.clientSocket.recv(2048)
                    self.receive += len(datareceive)
                    self.f.write(datareceive)
                    # print self.receive, self.cl
                    if not datareceive:
                        break
        except KeyboardInterrupt:
            t = open (self.tail, 'wb') 
            t.write(str(self.receive))
            t.close()
        self.clientSocket.close()

    def td(self):
        print "threading"  
        start = str(self.lsStart[self.number])
        stop = str(self.lsFinish[self.number])
        request = self.request(start, stop)
        print request
        self.clientSocket.send(request)
        print "send request"
        with open (self.fileName, 'a+') as self.f:
            while True:
                self.datareceive = self.clientSocket.recv(1)
                self.header += self.datareceive 
                if "\r\n\r\n" in self.header:
                    self.headerFinal, self.remain = self.header.split("\r\n\r\n")
                    self.receive += len(self.remain)
                    self.f.write(self.remain)
                    break
     
            contentLen = self.headerFinal.split()  
            i = 0
            for each in contentLen:
                # print each
                if each == "Content-Length:":
                    self.cl = contentLen[i+1]
                    break
                i += 1
 
            while True:
                datareceive = self.clientSocket.recv(2048)
                self.receive += len(datareceive)
                self.f.write(datareceive)
                # print self.receive, self.cl
                if not datareceive:
                    break
        self.clientSocket.close()

    def request(self, start_byte, end_byte):
        # host, path, port = parse_url(url)
        return "GET " + self.path + " HTTP/1.1\r\nHost: " + self.host + "\r\n" + "Connection: Close" + "\r\n" + "Range: bytes=" + start_byte + "-" + end_byte + "\r\n\r\n"

    def make_request(self,req_type, what, details, ver="1.1"):
        NL = "\r\n"
        req_line = "{verb} {w} HTTP/{v}".format(verb=req_type, w=what, v=ver)
        details = ["{name}: {v}".format(name=n,v=v) for (n,v) in details.iteritems()]
        detail_lines = NL.join(details)
        full_request = "".join([req_line, NL, detail_lines, NL, NL])
        return full_request

    def parse_url(self,url, DEFAULT_PORT=8080):
        parsed_url = urlparse(url)
        host, path, port = (parsed_url.hostname,parsed_url.path,parsed_url.port)
        if not port:
            port = DEFAULT_PORT
        return (host, path, port)

servName = sys.argv[-1]
if __name__ == '__main__':
    # print servName
    clients = [srget(servName)]
    asyncore.loop
print "finish"